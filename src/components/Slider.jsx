/**
 * Slider.jsx
 *
 * Logarithmic range slider. The values generated by the slider
 * are provided by SliderContext, which depends on logic contained
 * in ranger.js.
 */


import { useState, useRef, useContext, useEffect } from 'react'
import { SliderContext } from "../contexts/SliderContext"


export const Thumb = ({
  className,
  style,
  startDrag
}) => {

  return (
    <div
      className={`${className} thumb`}
      style={style }
      onMouseDown={startDrag}
      onTouchStart={startDrag}
    />
  )
}



export const Slider = () => {
  const {
    rangeData,
    setEnd,
    getAdjusted
  } = useContext(SliderContext)

  const { values, stringValue, ends } = rangeData

  // Used only once, in the initial useEffect
  const [ initialized, setInitialized ] = useState(false)

  const ref  = useRef()    // DOM element then maxX integer
  const { size, maxX } = (ref.current || {})
  const pxs  = maxX
             ? ends.map(( end, index ) => (
                end * maxX - index * size
              ))
             : [0, 0]

  const styles = pxs.map( end => (
    { left: end+"px", opacity: initialized * 1 }
  ))

  const background = {
    "--start": ends[0] * 100 + "%",
    "--end": ends[1] * 100 + "%"
  }


  const getPageX = (event) => {
    if (event.targetTouches &&Â event.targetTouches.length) {
      event = event.targetTouches[0] || {}
    }

    return event.pageX
  }


  const startDrag = (event) => {
    const pageX = getPageX(event)

    const { target, type } = event
    const isTouchEvent = type === "touchstart"
    const dragEvent = isTouchEvent ? "touchmove" : "mousemove"
    const dropEvent = isTouchEvent ? "touchend" : "mouseup"

    const index = target.classList.contains("right") + 0
    const left = pxs[index] + index * size
    const offset = left - pageX      // constant in closure
    let closureValue = values[index] // can be updated in closure

    const limits = index
    ? { min: pxs[0] + size * 2.2, max: maxX }
    : { min: 0, max: pxs[1] - size }


    /**
     * drag() is triggered by mousemove events
     */
    const drag = (event) => {
      const pageX = getPageX(event)

      const left = Math.max(
        limits.min,
        Math.min(
          pageX + offset,
          limits.max
      ))

      // Calculate the current value
      const { low, ratio } = getAdjusted(left / maxX)

      if (closureValue !== low) {
        setEnd(ratio, index)
        // Update within the startDrag closure
        closureValue = low
      }
    }

    /**
     * drop() is triggered by a mouseup event
     */
    const drop = () => {
      document.body.removeEventListener(dragEvent, drag, false)
    }

    // Start receiving mouse events until the mouse is released
    document.body.addEventListener(dragEvent, drag, false)
    document.body.addEventListener(dropEvent, drop, {once: true})
  }


  /**
   * initialize is only called once, immediately after the
   * component is mounted.
   */
  const initialize = () => {
    const slider = ref.current
    // The following assumes that the thumbs will be square
    const width = slider.clientWidth // without border
    const height = slider.clientHeight // without border

    // Re-use ref to hold the maxX value of the slider thumb
    ref.current = {
      size: height,
      maxX: width
    }

    // Force a re-render so that thumbs will be placed
    setInitialized(true)
  }


  useEffect(initialize, [])


  return (
    <div
      className="slider"
      style={background}
      ref={ref}
    >
      <p>{stringValue}</p>
      <Thumb
        className="left"
        style={styles[0]}
        startDrag={startDrag}
      />
      <Thumb
        className="right"
        style={styles[1]}
        startDrag={startDrag}
      />
    </div>
  )
}